<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="GenerateStronglyTypedLoggingMethod" xml:space="preserve">
    <value>Generate a strongly-typed logging method</value>
  </data>
  <data name="LegacyLoggingDescription" xml:space="preserve">
    <value>Identifies calls to legacy logging methods</value>
  </data>
  <data name="LegacyLoggingMessage" xml:space="preserve">
    <value>Use source generated logging methods for improved performance</value>
  </data>
  <data name="LegacyLoggingTitle" xml:space="preserve">
    <value>Use source generated logging methods for improved performance</value>
  </data>
  <data name="MemoryStreamDescription" xml:space="preserve">
    <value>Identifies uses of 'System.IO.MemoryStream' and recommends a better alternative</value>
  </data>
  <data name="MemoryStreamMessage" xml:space="preserve">
    <value>Use 'Microsoft.IO.RecyclableMemoryStream' instead of 'System.IO.MemoryStream' for improved performance</value>
  </data>
  <data name="MemoryStreamTitle" xml:space="preserve">
    <value>Use 'Microsoft.IO.RecyclableMemoryStream' instead of 'System.IO.MemoryStream' for improved performance</value>
  </data>
  <data name="DistributedCacheDescription" xml:space="preserve">
    <value>Calls to 'IDistributedCache.Get/GetAsync' can be replaced with faster alternatives from 'IExtendedDistributedCache'</value>
  </data>
  <data name="DistributedCacheMessage" xml:space="preserve">
    <value>Calls to 'IDistributedCache.Get/GetAsync' can be replaced with faster alternatives from 'IExtendedDistributedCache'</value>
  </data>
  <data name="DistributedCacheTitle" xml:space="preserve">
    <value>Use higher performance methods from 'IExtendedDistributedCache'</value>
  </data>
  <data name="UsingMicrosoftExtensionsCachingRedisTitle" xml:space="preserve">
    <value>Use the 'Microsoft.R9.Extensions.Caching.Redis' package instead of 'Microsoft.Extensions.Caching.StackExchangeRedis'</value>
  </data>
  <data name="UsingMicrosoftExtensionsCachingRedisDescription" xml:space="preserve">
    <value>Uses of the 'Microsoft.Extensions.Caching.StackExchangeRedis' package should be replaced with the 'Microsoft.R9.Extensions.Caching.Redis' package</value>
  </data>
  <data name="UsingMicrosoftExtensionsCachingRedisMessage" xml:space="preserve">
    <value>Use the 'Microsoft.R9.Extensions.Caching.Redis' package instead of 'Microsoft.Extensions.Caching.StackExchangeRedis'</value>
  </data>
  <data name="GenerateOrUpdateMetricMethod" xml:space="preserve">
    <value>Generate or update the metric method</value>
  </data>
  <data name="UsingMetricMethodDescription" xml:space="preserve">
    <value>Identifies issues in a method declaration corresponding to the metric attribute</value>
  </data>
  <data name="AddMissingMeterMessage" xml:space="preserve">
    <value>Add a parameter of type 'IMeter' as the first parameter to the method declaration</value>
  </data>
  <data name="AddMissingMeterTitle" xml:space="preserve">
    <value>Add a parameter of type 'IMeter' to the method declaration</value>
  </data>
  <data name="PartialMethodDeclarationMessage" xml:space="preserve">
    <value>Make method partial</value>
  </data>
  <data name="PartialMethodDeclarationTitle" xml:space="preserve">
    <value>Make method partial</value>
  </data>
  <data name="PublicMethodDeclarationMessage" xml:space="preserve">
    <value>Make method public</value>
  </data>
  <data name="PublicMethodDeclarationTitle" xml:space="preserve">
    <value>Make method public</value>
  </data>
  <data name="RemoveMethodBodyMessage" xml:space="preserve">
    <value>Remove method body</value>
  </data>
  <data name="RemoveMethodBodyTitle" xml:space="preserve">
    <value>Remove method body</value>
  </data>
  <data name="StaticMethodDeclarationMessage" xml:space="preserve">
    <value>Make method static</value>
  </data>
  <data name="StaticMethodDeclarationTitle" xml:space="preserve">
    <value>Make method static</value>
  </data>
  <data name="UpdateDimensionParamTypesMessage" xml:space="preserve">
    <value>Update method parameters for dimensions to be string type</value>
  </data>
  <data name="UpdateDimensionParamTypesTitle" xml:space="preserve">
    <value>Update method parameters for dimensions to be string type</value>
  </data>
  <data name="UpdateReturnTypeMessage" xml:space="preserve">
    <value>Update return type to be the strong type being created for this metric</value>
  </data>
  <data name="UpdateReturnTypeTitle" xml:space="preserve">
    <value>Update return type to match metric type</value>
  </data>
  <data name="SealClass" xml:space="preserve">
    <value>Seal class</value>
  </data>
  <data name="SealInternalClassDescription" xml:space="preserve">
    <value>Identifies classes which can be optimized by being sealed</value>
  </data>
  <data name="SealInternalClassMessage" xml:space="preserve">
    <value>Seal class '{0}' for improved performance</value>
  </data>
  <data name="SealInternalClassTitle" xml:space="preserve">
    <value>Seal non-public classes for improved performance</value>
  </data>
  <data name="ThrowsExpressionDescription" xml:space="preserve">
    <value>Recommends replacing explicit argument throwing with the more efficient 'Microsoft.R9.Extensions.Diagnostics.Throws' class</value>
  </data>
  <data name="ThrowsExpressionMessage" xml:space="preserve">
    <value>Use '{0}' to throw the exception instead to improve performance</value>
  </data>
  <data name="ThrowsExpressionTitle" xml:space="preserve">
    <value>Use the 'Microsoft.R9.Extensions.Diagnostics.Throws' class instead of explicitly throwing exception for improved performance</value>
  </data>
  <data name="ThrowsStatementDescription" xml:space="preserve">
    <value>Recommends replacing explicit argument throwing with the more efficient 'Microsoft.R9.Extensions.Diagnostics.Throws' class</value>
  </data>
  <data name="ThrowsStatementMessage" xml:space="preserve">
    <value>Use '{0}' to throw the exception instead to improve performance</value>
  </data>
  <data name="ThrowsStatementTitle" xml:space="preserve">
    <value>Use the 'Microsoft.R9.Extensions.Diagnostics.Throws' class instead of explicitly throwing exception for improved performance</value>
  </data>
  <data name="ReplaceWithStaticNullCheckMethod" xml:space="preserve">
    <value>Replace explicit null check with call to 'Throws.IfNull' (needs a 'PackageReference' to 'Microsoft.R9.Extensions.Essentials')</value>
  </data>
  <data name="ReplaceWithStaticThrowMethod" xml:space="preserve">
    <value>Replace explicit throw with call to 'Throws' (needs a 'PackageReference' to 'Microsoft.R9.Extensions.Essentials')</value>
  </data>
  <data name="BlockingCallDescription" xml:space="preserve">
    <value>Modern .NET code should avoid blocking I/O calls since they substantially impact performance</value>
  </data>
  <data name="BlockingCallMessage" xml:space="preserve">
    <value>Use asynchronous operations instead of legacy thread blocking code</value>
  </data>
  <data name="BlockingCallTitle" xml:space="preserve">
    <value>Use asynchronous operations instead of legacy thread blocking code</value>
  </data>
  <data name="StringFormatDescription" xml:space="preserve">
    <value>Identifies uses of 'String.Format' and 'StringBuilder.AppendFormat'</value>
  </data>
  <data name="StringFormatMessage" xml:space="preserve">
    <value>Use 'Microsoft.R9.Extensions.Text.CompositeFormat' instead of 'string.Format' for improved performance</value>
  </data>
  <data name="StringFormatTitle" xml:space="preserve">
    <value>Use 'Microsoft.R9.Extensions.Text.CompositeFormat' instead of 'string.Format' for improved performance</value>
  </data>
  <data name="UsingExcessiveDictionaryLookupDescription" xml:space="preserve">
    <value>Encourages optimal use of dictionary lookup</value>
  </data>
  <data name="UsingExcessiveDictionaryLookupMessage" xml:space="preserve">
    <value>Remove excessive dictionary lookups</value>
  </data>
  <data name="UsingExcessiveDictionaryLookupTitle" xml:space="preserve">
    <value>Remove unnecessary dictionary lookups</value>
  </data>
  <data name="UsingExcessiveSetLookupDescription" xml:space="preserve">
    <value>Encourages optimal use of set lookup</value>
  </data>
  <data name="UsingExcessiveSetLookupMessage" xml:space="preserve">
    <value>Remove excessive set lookups</value>
  </data>
  <data name="UsingExcessiveSetLookupTitle" xml:space="preserve">
    <value>Remove unnecessary set lookups</value>
  </data>
  <data name="UsingToStringInLoggersDescription" xml:space="preserve">
    <value>Identifies calls to the 'ToString' method as arguments to an R9 logging method</value>
  </data>
  <data name="UsingToStringInLoggersMessage" xml:space="preserve">
    <value>Provide a logging method that accepts an instance of the object instead of a string</value>
  </data>
  <data name="UsingToStringInLoggersTitle" xml:space="preserve">
    <value>Perform message formatting in the body of the logging method</value>
  </data>
  <data name="StaticTimeDescription" xml:space="preserve">
    <value>Identifies uses of time dependent APIs that can lead to flaky tests</value>
  </data>
  <data name="StaticTimeMessage" xml:space="preserve">
    <value>Use 'Microsoft.R9.Extensions.Time.IClock' to make the code easier to test</value>
  </data>
  <data name="StaticTimeTitle" xml:space="preserve">
    <value>Use 'Microsoft.R9.Extensions.Time.IClock' to make the code easier to test</value>
  </data>
  <data name="StopwatchDescription" xml:space="preserve">
    <value>Identifies uses of 'System.Diagnostics.Stopwatch'</value>
  </data>
  <data name="StopwatchMessage" xml:space="preserve">
    <value>Use 'Microsoft.R9.Extensions.Time.PerfStopwatch' instead of 'System.Diagnostics.Stopwatch' for improved performance</value>
  </data>
  <data name="StopwatchTitle" xml:space="preserve">
    <value>Use 'Microsoft.R9.Extensions.Time.PerfStopwatch' instead of 'System.Diagnostics.Stopwatch' for improved performance</value>
  </data>
  <data name="SensitiveDataClassifierPropagationDescription" xml:space="preserve">
    <value>A declared type contains members that have data classifications that are not included in the data classifications annotating the declared type. Consider propagating the data classifications from the type's members to the type itself.</value>
  </data>
  <data name="SensitiveDataClassifierPropagationMessage" xml:space="preserve">
    <value>Type '{0}' contains members with data classifications that are not included on the type itself. Propagate the data classification.</value>
  </data>
  <data name="SensitiveDataClassifierPropagationTitle" xml:space="preserve">
    <value>Propagate data classification</value>
  </data>
  <data name="SequentialFixAllFormat" xml:space="preserve">
    <value>Apply code fix for all issues in '{0}' '{1}'</value>
  </data>
  <data name="SequentialFixAllInSolution" xml:space="preserve">
    <value>Apply code fix for all issues in current solution</value>
  </data>
  <data name="UserInputFromRequestAnalyzerDescription" xml:space="preserve">
    <value>Only Request Context members should be passed as parameters to invoke APIs which are annotated as User Data APIs</value>
  </data>
  <data name="UserInputFromRequestAnalyzerMessage" xml:space="preserve">
    <value>Argument '{0}' passed to the user data vending API '{1}''s parameter '{2}' is not an instance of '{3}'</value>
  </data>
  <data name="UserInputFromRequestAnalyzerTitle" xml:space="preserve">
    <value>Argument provided for user input parameter on user data vending API is not from any request context</value>
  </data>
  <data name="UseObsoleteAttributeMessageFormatTemplate" xml:space="preserve">
    <value>Use fixed obsolete attribute message format</value>
  </data>
  <data name="UseSoftDeleteObsoleteAttributeFormat" xml:space="preserve">
    <value>Use fixed obsolete attribute message format for soft deleted API</value>
  </data>
  <data name="UsingExperimentalApiDescription" xml:space="preserve">
    <value>Indicates that code is depending on an experimental API</value>
  </data>
  <data name="UsingExperimentalApiTitle" xml:space="preserve">
    <value>Using experimental API</value>
  </data>
  <data name="UsingExperimentalApiMessage" xml:space="preserve">
    <value>'{0}' is experimental and is subject to change without notice</value>
  </data>
  <data name="StartsEndsWithDescription" xml:space="preserve">
    <value>When checking for a single character, prefer the character overloads of 'String.StartsWith' and 'String.EndsWith' for improved performance</value>
  </data>
  <data name="StartsEndsWithMessage" xml:space="preserve">
    <value>Use the character-based overload of '{0}'</value>
  </data>
  <data name="StartsEndsWithTitle" xml:space="preserve">
    <value>Use the character-based overloads of 'String.StartsWith' or 'String.EndsWith'</value>
  </data>
  <data name="MakeExeTypesInternalDescription" xml:space="preserve">
    <value>Making an executable's types internal enables dead code analysis along with other potential optimizations</value>
  </data>
  <data name="MakeExeTypesInternalMessage" xml:space="preserve">
    <value>Make type '{0}' internal since it is declared in an executable</value>
  </data>
  <data name="MakeExeTypesInternalTitle" xml:space="preserve">
    <value>Make types declared in an executable internal</value>
  </data>
  <data name="ArraysDescription" xml:space="preserve">
    <value>Dictionaries and sets which use enums and bytes as keys can often be replaced with simple arrays for improved performance</value>
  </data>
  <data name="ArraysMessage" xml:space="preserve">
    <value>Consider using '{0}?[]' instead of '{1}'</value>
  </data>
  <data name="ArraysTitle" xml:space="preserve">
    <value>Consider using an array instead of a collection</value>
  </data>
  <data name="EnumStringsDescription" xml:space="preserve">
    <value>Replace uses of 'Enum.GetName' and 'Enum.ToString' for improved performance</value>
  </data>
  <data name="EnumStringsTitle" xml:space="preserve">
    <value>Replace uses of 'Enum.GetName' and 'Enum.ToString' for improved performance</value>
  </data>
  <data name="EnumStringsMessage" xml:space="preserve">
    <value>Use {0} instead of '{1}' for improved performance</value>
  </data>
  <data name="ToInvariantStringDescription" xml:space="preserve">
    <value>'Microsoft.R9.Extensions.Text.NumericExtensions.ToInvariantString' provides caching for common numeric values, avoiding the need to allocate new strings in many situations</value>
  </data>
  <data name="ToInvariantStringMessage" xml:space="preserve">
    <value>Use 'Microsoft.R9.Extensions.Text.NumericExtensions.ToInvariantString' for improved performance</value>
  </data>
  <data name="ToInvariantStringTitle" xml:space="preserve">
    <value>Use 'Microsoft.R9.Extensions.Text.NumericExtensions.ToInvariantString' for improved performance</value>
  </data>
  <data name="ValueTupleDescription" xml:space="preserve">
    <value>Using 'System.ValueTuple' avoids allocations and is generally more efficient than 'System.Tuple'</value>
  </data>
  <data name="ValueTupleMessage" xml:space="preserve">
    <value>Use 'System.ValueTuple' instead of 'System.Tuple' for improved performance</value>
  </data>
  <data name="ValueTupleTitle" xml:space="preserve">
    <value>Use 'System.ValueTuple' instead of 'System.Tuple' for improved performance</value>
  </data>
  <data name="ObjectPoolDescription" xml:space="preserve">
    <value>Use 'Microsoft.R9.Extensions.Pools.PoolFactory' instead for improved performance</value>
  </data>
  <data name="ObjectPoolMessage" xml:space="preserve">
    <value>Use 'Microsoft.R9.Extensions.Pools.PoolFactory' instead of '{0}' for improved performance</value>
  </data>
  <data name="ObjectPoolTitle" xml:space="preserve">
    <value>Use 'Microsoft.R9.Extensions.Pools.PoolFactory' instead for improved performance</value>
  </data>
  <data name="NullCheckDescription" xml:space="preserve">
    <value>When compiling in a nullable context, the C# compiler performs null analysis at compile time so there is no need to also perform null checking at runtime</value>
  </data>
  <data name="NullCheckMessage" xml:space="preserve">
    <value>Remove superfluous null check when compiling in a nullable context</value>
  </data>
  <data name="NullCheckTitle" xml:space="preserve">
    <value>Remove superfluous null checks when compiling in a nullable context</value>
  </data>
  <data name="MakeTypeInternal" xml:space="preserve">
    <value>Make the type internal</value>
  </data>
  <data name="LegacyCollectionDescription" xml:space="preserve">
    <value>Using generic collections can avoid boxing overhead and provides strong typing</value>
  </data>
  <data name="LegacyCollectionMessage" xml:space="preserve">
    <value>Use generic collections instead of legacy collections for improved performance</value>
  </data>
  <data name="LegacyCollectionTitle" xml:space="preserve">
    <value>Use generic collections instead of legacy collections for improved performance</value>
  </data>
  <data name="UseConcreteTypeDescription" xml:space="preserve">
    <value>Using concrete types avoid virtual or interface call overhead and enables inlining</value>
  </data>
  <data name="UseConcreteTypeForFieldMessage" xml:space="preserve">
    <value>Change type of field '{0}' from '{1}' to '{2}' for improved performance</value>
  </data>
  <data name="UseConcreteTypeTitle" xml:space="preserve">
    <value>Use concrete types when possible for improved performance</value>
  </data>
  <data name="UseConcreteTypeForLocalMessage" xml:space="preserve">
    <value>Change type of variable '{0}' from '{1}' to '{2}' for improved performance</value>
  </data>
  <data name="UseConcreteTypeForMethodReturnMessage" xml:space="preserve">
    <value>Change return type of method '{0}' from '{1}' to '{2}' for improved performance</value>
  </data>
  <data name="UseConcreteTypeForParameterMessage" xml:space="preserve">
    <value>Change type of parameter '{0}' from '{1}' to '{2}' for improved performance</value>
  </data>
  <data name="SplitDescription" xml:space="preserve">
    <value>Use 'Microsoft.R9.Extensions.Text.StringSplitExtensions.TrySplit' for improved performance</value>
  </data>
  <data name="SplitMessage" xml:space="preserve">
    <value>Use 'Microsoft.R9.Extensions.Text.StringSplitExtensions.TrySplit' for improved performance</value>
  </data>
  <data name="SplitTitle" xml:space="preserve">
    <value>Use 'Microsoft.R9.Extensions.Text.StringSplitExtensions.TrySplit' for improved performance</value>
  </data>
  <data name="UserDataAPIAllParametersAnnotatedDescription" xml:space="preserve">
    <value>All parameters of User Data APIs should be annotated with either UserInputFromRequest or RequestAgnosticAPIParameter attributes</value>
  </data>
  <data name="UserDataAPIAllParametersAnnotatedMessage" xml:space="preserve">
    <value>Parameter {0} on User Data API {1} should be annotated with either UserInputFromRequest if it originates from a Http request, or RequestAgnosticAPIParameter if not</value>
  </data>
  <data name="UserDataAPIAllParametersAnnotatedTitle" xml:space="preserve">
    <value>Annotate all User Data APIs parameters</value>
  </data>
  <data name="MakeArrayStaticDescription" xml:space="preserve">
    <value>Arrays of literal values should generally be assigned to static fields in order to avoid creating them redundantly over time</value>
  </data>
  <data name="MakeArrayStaticMessage" xml:space="preserve">
    <value>Assign array of literal values to a static field for improved performance</value>
  </data>
  <data name="MakeArrayStaticTitle" xml:space="preserve">
    <value>Assign array of literal values to a static field for improved performance</value>
  </data>
  <data name="AnyDescription" xml:space="preserve">
    <value>Using the 'Count' or 'Length' properties to determine if a collection is empty is considerably more efficient than using the 'Any' LINQ method</value>
  </data>
  <data name="AnyMessage" xml:space="preserve">
    <value>Use the '{0}' property instead of the 'Any' method for improved performance</value>
  </data>
  <data name="AnyTitle" xml:space="preserve">
    <value>Use the 'Count' or 'Length' properties instead of the 'Any' method for improved performance</value>
  </data>
  <data name="ExperimentalSymbolsCantBeMarkedObsoleteDescription" xml:space="preserve">
    <value>Symbols being added to the public API of an assembly cannot be marked as obsolete</value>
  </data>
  <data name="ExperimentalSymbolsCantBeMarkedObsoleteMessage" xml:space="preserve">
    <value>Experimental symbol '{0}' cannot be marked as obsolete</value>
  </data>
  <data name="ExperimentalSymbolsCantBeMarkedObsoleteTitle" xml:space="preserve">
    <value>Experimental symbols cannot be marked as obsolete</value>
  </data>
  <data name="NewSymbolsMustBeMarkedExperimentalDescription" xml:space="preserve">
    <value>Symbols being added to the public API of an assembly must be marked as experimental until they have been appoved</value>
  </data>
  <data name="NewSymbolsMustBeMarkedExperimentalMessage" xml:space="preserve">
    <value>Newly added symbol '{0}' must be marked as experimental</value>
  </data>
  <data name="NewSymbolsMustBeMarkedExperimentalTitle" xml:space="preserve">
    <value>Newly added symbols must be marked as experimental</value>
  </data>
  <data name="PublishedSymbolsCantBeDeletedDescription" xml:space="preserve">
    <value>Published symbols cannot be deleted to maintain compatibility</value>
  </data>
  <data name="PublishedSymbolsCantBeDeletedMessage" xml:space="preserve">
    <value>Published symbol '{0}' cannot be deleted to maintain compatibility</value>
  </data>
  <data name="PublishedSymbolsCantBeDeletedTitle" xml:space="preserve">
    <value>Published symbols cannot be deleted to maintain compatibility</value>
  </data>
  <data name="DeprecatedSymbolsMustBeMarkedObsoleteMessage" xml:space="preserve">
    <value>Deprecated symbol '{0}' must be annotated as obsolete</value>
  </data>
  <data name="DeprecatedSymbolsMustBeMarkedObsoleteTitle" xml:space="preserve">
    <value>Deprecated symbols must be annotated as obsolete</value>
  </data>
  <data name="PublishedSymbolsCantBeMarkedExperimentalDescription" xml:space="preserve">
    <value>Previously published symbols in the public API of an assembly cannot be marked experimental</value>
  </data>
  <data name="PublishedSymbolsCantBeMarkedExperimentalMessage" xml:space="preserve">
    <value>Published symbol '{0}' cannot be marked experimental</value>
  </data>
  <data name="PublishedSymbolsCantBeMarkedExperimentalTitle" xml:space="preserve">
    <value>Published symbols cannot be marked experimental</value>
  </data>
  <data name="PublishedSymbolsCantChangeDescription" xml:space="preserve">
    <value>Published symbols cannot change to maintain compatibility</value>
  </data>
  <data name="PublishedSymbolsCantChangeMessage" xml:space="preserve">
    <value>Published symbol '{0}' cannot be changed to maintain compatibility</value>
  </data>
  <data name="PublishedSymbolsCantChangedTitle" xml:space="preserve">
    <value>Published symbols cannot be changed to maintain compatibility</value>
  </data>
  <data name="ReplaceAnyCallWithPropertyAccess" xml:space="preserve">
    <value>Replace 'Any' method call with property access</value>
  </data>
  <data name="AsyncCallInsideUsingBlockDescription" xml:space="preserve">
    <value>When skipping the await keyword for asynchronous operations inside a using block, then a disposable object could be disposed before the asynchronous invocation finishes. This might result in incorrect behavior and very often ends with a runtime exception notifying that the code is trying to operate on a disposed object.</value>
  </data>
  <data name="AsyncCallInsideUsingBlockMessage" xml:space="preserve">
    <value>Async call should be awaited before leaving the 'using' block</value>
  </data>
  <data name="AsyncCallInsideUsingBlockTitle" xml:space="preserve">
    <value>Fire-and-forget async call inside a 'using' block</value>
  </data>
  <data name="ConditionalAccessDescription" xml:space="preserve">
    <value>Using the conditional access operator (?) to access values which are statically known not to be null causes superfluous null checks to be performed at runtime</value>
  </data>
  <data name="ConditionalAccessMessage" xml:space="preserve">
    <value>Consider removing unnecessary conditional access operator (?) since the value is statically known not to be null</value>
  </data>
  <data name="ConditionalAccessTitle" xml:space="preserve">
    <value>Consider removing unnecessary conditional access operator (?)</value>
  </data>
  <data name="CoalesceAssignmentDescription" xml:space="preserve">
    <value>Using the null coalescing assignment operator (??=) with values which are statically known not to be null causes superfluous null checks to be performed at runtime</value>
  </data>
  <data name="CoalesceAssignmentMessage" xml:space="preserve">
    <value>Consider removing unnecessary null coalescing assignment (??=) since the target value is statically known not to be null</value>
  </data>
  <data name="CoalesceAssignmentTitle" xml:space="preserve">
    <value>Consider removing unnecessary null coalescing assignment (??=)</value>
  </data>
  <data name="CoalesceDescription" xml:space="preserve">
    <value>Using the null coalescing operator (??) with values which are statically known to be null causes superfluous null checks to be performed at runtime</value>
  </data>
  <data name="CoalesceMessage" xml:space="preserve">
    <value>Consider removing unnecessary null coalescing (??) since the left-hand value is statically known not to be null</value>
  </data>
  <data name="CoalesceTitle" xml:space="preserve">
    <value>Consider removing unnecessary null coalescing operator (??)</value>
  </data>
  <data name="AsyncMethodWithoutCancellationDescription" xml:space="preserve">
    <value>Accepting a CancellationToken as a parameter allows caller to express a loss of interest in the result enabling the method to save cycles by finishing early</value>
  </data>
  <data name="AsyncMethodWithoutCancellationMessage" xml:space="preserve">
    <value>Add CancellationToken as the parameter of asynchronous method</value>
  </data>
  <data name="AsyncMethodWithoutCancellationTitle" xml:space="preserve">
    <value>The async method doesn't support cancellation</value>
  </data>
  <data name="AnnotateExperimentalApi" xml:space="preserve">
    <value>Annotate experimental API</value>
  </data>
  <data name="DeprecatedSymbolsMustBeMarkedObsoleteDescription" xml:space="preserve">
    <value>Symbols that have been removed from the public API of an assembly must be marked as obsolete</value>
  </data>
</root>